assert = require('assert');
util = require('util');
dollop = require('./');
mkdirp = require('mkdirp');
rimraf = require('rimraf');
idgen = require('idgen');
fs = require('fs');
path = require('path');
sinon = require('sinon');
sinon.assert.expose(global);

instrument = function (s) {
  ['all', 'add', 'update', 'remove', 'error', 'scan'].forEach(function (ev) {
    var name = 'on' + ev.slice(0, 1).toUpperCase() + ev.slice(1);
    s[name] = sinon.spy();
    s.on(ev, s[name]);
  });
}

wait = function (cb) {
  setTimeout(cb, 1000);
}

isDir = function (stat) {
  return stat.isDirectory();
}

isFile = function (stat) {
  return !stat.isDirectory();
}

describe('basic', function () {
  var testDir = '/tmp/dollop-test-' + idgen()
    , s, s2

  function matchEntry (p, statMatcher) {
    return function (file) {
      try {
        assert.strictEqual(file.fullPath, testDir + '/' + p);
        assert(statMatcher(file.stat));
        return true;
      }
      catch (e) {
        return false;
      }
    };
  }

  beforeEach(function() {
    [s, s2].forEach(function (s) {
      if (s) {
        s.onAdd.reset();
        s.onUpdate.reset();
        s.onRemove.reset();
      }
    });
  });
  before(function (done) {
    mkdirp(testDir, function (err) {
      if (err) return done(err);
      fs.realpath(testDir, function (err, resolvedPath) {
        if (err) return done(err);
        testDir = resolvedPath;
        done();
      });
    });
  });
  before(function (done) {
    s = dollop(testDir).on('ready', function (files) {
      assert.equal(files.length, 0);
      done();
    });
    assert(dollop.isDollop(s));
    assert(!dollop.isDollop({something: 'else'}));
    instrument(s);
  });
  after(function (done) {
    rimraf(testDir, done);
  });
  it('listens for file', function (done) {
    fs.writeFile(testDir + '/beans', 'beans', assert.ifError);
    wait(function () {
      assertCalledOnce(s.onAdd);
      assertCalledWithMatch(s.onAdd, matchEntry('beans', isFile));
      assertNotCalled(s.onUpdate);
      assertNotCalled(s.onRemove);
      done();
    });
  });
  it('listens for new dirs', function (done) {
    mkdirp(testDir + '/rice/beans');
    wait(function () {
      assertCalledTwice(s.onAdd);
      assertCalledWithMatch(s.onAdd, matchEntry('rice', isDir));
      assertCalledWithMatch(s.onAdd, matchEntry('rice/beans', isDir));
      assertNotCalled(s.onUpdate);
      assertNotCalled(s.onRemove);
      done();
    });
  });
  it('listens for new file in sub dir', function (done) {
    fs.writeFile(testDir + '/rice/beans/meat', 'meat is neat', assert.ifError);
    wait(function () {
      assertCalledOnce(s.onAdd);
      assertCalledWithMatch(s.onAdd, matchEntry('rice/beans/meat', isFile));
      assertNotCalled(s.onUpdate);
      assertNotCalled(s.onRemove);
      done();
    });
  });
  it('listens for another new file', function (done) {
    fs.writeFile(testDir + '/rice/taters', 'tater treats', assert.ifError);
    wait(function () {
      assertCalledOnce(s.onAdd);
      assertCalledWithMatch(s.onAdd, matchEntry('rice/taters', isFile));
      assertNotCalled(s.onUpdate);
      assertNotCalled(s.onRemove);
      done();
    });
  });
  it('detects single remove', function (done) {
    fs.unlink(testDir + '/beans', assert.ifError);
    wait(function () {
      assertCalledOnce(s.onRemove);
      assertCalledWithMatch(s.onRemove, matchEntry('beans', isFile));
      assertNotCalled(s.onAdd);
      assertNotCalled(s.onUpdate);
      done();
    });
  });
  it('another mkdirp', function (done) {
    mkdirp(testDir + '/bugs/sauce/turmoil');
    wait(function () {
      assertCalledThrice(s.onAdd);
      assertCalledWithMatch(s.onAdd, matchEntry('bugs', isDir));
      assertCalledWithMatch(s.onAdd, matchEntry('bugs/sauce', isDir));
      assertCalledWithMatch(s.onAdd, matchEntry('bugs/sauce/turmoil', isDir));
      assertNotCalled(s.onUpdate);
      assertNotCalled(s.onRemove);
      done();
    });
  });
  it('multiple dollops', function (done) {
    s2 = dollop(testDir).on('ready', function (files) {
      assert.equal(files.length, 7);
      var paths = files.map(function (file) {
        return file.path;
      });
      assert.deepEqual(paths.sort(), [
        'bugs',
        'bugs/sauce',
        'bugs/sauce/turmoil',
        'rice',
        'rice/beans',
        'rice/beans/meat',
        'rice/taters'
      ]);
      done();
    });
    instrument(s2);
  });
  it('detects update', function (done) {
    fs.writeFile(testDir + '/rice/beans/meat', 'quite a treat', assert.ifError);
    wait(function () {
      [s, s2].forEach(function (s) {
        assertCalledOnce(s.onUpdate);
        assertCalledWithMatch(s.onUpdate, matchEntry('rice/beans/meat', isFile));
        assertNotCalled(s.onAdd);
        assertNotCalled(s.onRemove);
      });
      done();
    });
  });
  it('detects rimraf', function (done) {
    rimraf(testDir + '/rice', assert.ifError);
    wait(function () {
      [s, s2].forEach(function (s) {
        //assert.equal(s.onRemove.callCount, 4);
        assertCalledWithMatch(s.onRemove, matchEntry('rice', isDir));
        assertCalledWithMatch(s.onRemove, matchEntry('rice/beans', isDir));
        assertCalledWithMatch(s.onRemove, matchEntry('rice/beans/meat', isFile));
        assertCalledWithMatch(s.onRemove, matchEntry('rice/taters', isFile));
        assertNotCalled(s.onAdd);
        assertNotCalled(s.onUpdate);
      });
      done();
    });
  });
  it('detects remove of empty dir', function (done) {
    fs.rmdir(testDir + '/bugs/sauce/turmoil', assert.ifError);
    wait(function () {
      [s, s2].forEach(function (s) {
        assertCalledOnce(s.onRemove);
        assertCalledWithMatch(s.onRemove, matchEntry('bugs/sauce/turmoil', isDir));
        assertNotCalled(s.onUpdate);
        assertNotCalled(s.onAdd);
      });
      done();
    });
  });
  it('detects add after remove', function (done) {
    mkdirp(testDir + '/rice/taters', assert.ifError);
    wait(function () {
      [s, s2].forEach(function (s) {
        assertCalledTwice(s.onAdd);
        assertCalledWithMatch(s.onAdd, matchEntry('rice', isDir));
        assertCalledWithMatch(s.onAdd, matchEntry('rice/taters', isDir));
        assertNotCalled(s.onUpdate);
        assertNotCalled(s.onRemove);
      });
      done();
    });
  });
  it('unwatch', function (done) {
    [s, s2].forEach(function (s) { s.close(); });
    rimraf(testDir + '/bugs', assert.ifError);
    wait(function () {
      [s, s2].forEach(function (s) {
        assertNotCalled(s.onAdd);
        assertNotCalled(s.onUpdate);
        assert.equal(s.onRemove.callCount, 4);
        assertCalledWithMatch(s.onRemove, matchEntry('rice', isDir));
        assertCalledWithMatch(s.onRemove, matchEntry('rice/taters', isDir));
        assertCalledWithMatch(s.onRemove, matchEntry('bugs', isDir));
        assertCalledWithMatch(s.onRemove, matchEntry('bugs/sauce', isDir));
      });
      done();
    });
  });
  it('event counts', function () {
    //assert.equal(s.onAll.callCount, 50);
    //assert.equal(s2.onAll.callCount, 35);
    assertNotCalled(s.onError);
    assertNotCalled(s2.onError);
  });
});

describe('dotfile', function () {
  var testDir = '/tmp/dollop-test-' + idgen()
    , s

  function matchEntry (p, statMatcher) {
    return function (file) {
      return file.fullPath === testDir + '/' + p && file.path === p && statMatcher(file.stat);
    };
  }

  before(function (done) {
    mkdirp(testDir, function (err) {
      if (err) return done(err);
      fs.realpath(testDir, function (err, resolvedPath) {
        if (err) return done(err);
        testDir = resolvedPath;
        done();
      });
    });
  });
  before(function (done) {
    s = dollop(testDir, {dot: true}).on('ready', function (files) {
      assert.equal(files.length, 0);
      done();
    });
    instrument(s);
  });
  beforeEach(function() {
    s.onAdd.reset();
    s.onUpdate.reset();
    s.onRemove.reset();
  });
  after(function (done) {
    rimraf(testDir, done);
  });
  it('listens for dotfile', function (done) {
    fs.writeFile(testDir + '/.config', 'duh', assert.ifError);
    wait(function () {
      assertCalledOnce(s.onAdd);
      assertCalledWithMatch(s.onAdd, matchEntry('.config', isFile));
      assertNotCalled(s.onUpdate);
      assertNotCalled(s.onRemove);
      done();
    });
  });
});

describe('relative paths', function () {
  var s;
  it('creates proper relative paths', function (done) {
    var cwd = path.resolve('fixtures');
    s = dollop(['views/**/*.hbs', 'public/templates/**/*.hbs', 'haha.hbs'], {dot: true, cwd: cwd}).on('ready', function (files) {
      var names = [];
      files.forEach(function (file) {
        if (file.name === 'lol.hbs') {
          assert.equal(file.path, 'views/lol.hbs');
          assert.equal(file.cwd, cwd);
          assert.equal(file.fullPath, path.join(cwd, file.path));
          assert.equal(file.key, '/lol.hbs');
          assert.equal(file.parentDir, 'views');
          assert.equal(file.fullParentDir, path.join(cwd, 'views'));
          names.push(file.name);
        }
        else if (file.name === 'something.hbs') {
          assert.equal(file.path, 'public/templates/something.hbs');
          assert.equal(file.cwd, cwd);
          assert.equal(file.fullPath, path.join(cwd, file.path));
          assert.equal(file.key, '/something.hbs');
          assert.equal(file.parentDir, 'public/templates');
          assert.equal(file.fullParentDir, path.join(cwd, 'public/templates'));
          names.push(file.name);
        }
        else if (file.name === 'haha.hbs') {
          assert.equal(file.path, 'haha.hbs');
          assert.equal(file.cwd, cwd);
          assert.equal(file.fullPath, path.join(cwd, file.path));
          assert.equal(file.key, '/haha.hbs');
          assert.equal(file.parentDir, '.');
          assert.equal(file.fullParentDir, cwd);
          names.push(file.name);
        }
      });
      assert.deepEqual(names.sort(), ['haha.hbs', 'lol.hbs', 'something.hbs']);
      done();
    });
  });
});